#Markup file to define x86 equivalents of 6502 instructions

#TODO
#====
#op [rsp] is 32 or 64 bit?
#passing arg to calc_IY etc seems extraneous

#Register definitions
#====================
DEF A8 al
DEF A32 eax
DEF A64 rax
DEF X8 bl
DEF X32 ebx
DEF X64 rbx
DEF Y8 cl
DEF Y32 ecx
DEF Y64 rcx
DEF SP8 dil
DEF SP32 edi
DEF SP64 rdi
DEF temp8 dl
DEF temp8h dh
DEF temp32 edx
DEF temp64 rdx
DEF D_reg r12d
DEF BCD1 sil
DEF BCD2 r13b


#Addressing modes
#================
MODE ABS byte[ mem6502 + %arg ] 
MODE ABSX byte [ rbx + mem6502 + %arg ]
MODE ABSY byte [ rcx + mem6502 + %arg ]
MODE IMMED %arg
MODE ZP byte[ mem6502 + %arg ]
MODE ZPX byte [ rbx + mem6502 + %arg ]
MODE ZPY byte [ rcx + mem6502 + %arg ]


#Old flag setting - doesn't work
#===============================
#Set NZ flags based on bl and keep CV
BLOCK set_NZ_keep_CV_v1
    ;THIS DOES NOT WORK! OF flag is not in first 8 bits
    ;ALSO FLAGS CHANGED! see commented out in template

    #Copy flags into ah
    lahf
    #Set SF and ZF to zero
    and eax,~(MASK_SF_FLAG|MASK_ZF_FLAG)   
 
    #Check if bl==0
    cmp ebx,0
    sete cl
    #Shift ZF flag to correct position in ah
    sal ecx,MASK_ZF_SHIFT
    #Set ZF in ah
    or eax,ecx 
    
    #Check if bl negative
    test ebx,0x80
    setne cl
    #Shift SF flag to correct position in ah
    sal ecx,MASK_SF_SHIFT
    #Set SF in ah
    or eax, ecx 
    
    #Copy ah to flags
    sahf
END

BLOCK set_NZ_keep_CV_v2
    ;Does not work by itself!
    test %1 , %1
END


#Flag setting
#============
#BLOCK set_NZ_keep_CV_v3
BLOCK set_NZ_keep_CV
    pushfq
    pop %temp64
    and %temp32 , MASK_CF_FLAG|MASK_OF_FLAG
    test %1 , %1
    pushfq
    or [rsp], %temp32
    popfq
END

BLOCK keep_CV_pre
    pushfq
    and dword [rsp], MASK_CF_FLAG|MASK_OF_FLAG
END

BLOCK keep_CV_post
    pushfq
    pop %temp64
    or [rsp], %temp32
    popfq
END

BLOCK keep_V_pre
    pushfq
END

BLOCK keep_V_post
    pushfq
    pop %temp64
    and %temp32 , ~MASK_OF_FLAG
    and dword [rsp], MASK_OF_FLAG
    or [rsp], %temp32
    popfq
END

BLOCK set_CNZ_keep_V_1
    ;Save V flag
    pushfq
END

BLOCK set_CNZ_keep_V_2
    ;Save C generated by shift
    pushfq
END

BLOCK set_CNZ_keep_V_3
    ;Save N and Z generated by shift
    pushfq 
    pop %temp64
    and %temp32 , MASK_SF_FLAG|MASK_ZF_FLAG
    and dword [rsp], MASK_CF_FLAG
    or %temp64 , [rsp]
    add rsp, 8
    and dword [rsp], MASK_OF_FLAG
    or [rsp], %temp32
    popfq
END


#Addressing modes
#================
BLOCK calc_IX
    lea %temp32 , [ %X64 + %arg ]
    movzx %temp32 , %temp8
    movzx %temp32 , word [ mem6502 + %temp64 ]
END

DEF IX_address byte [ mem6502 + %temp64 ]

BLOCK calc_IY 
    movzx %temp32 , word [ mem6502 + %arg ]  
END

DEF IY_address byte [ mem6502 + %Y64 + %temp64 ]

BLOCK calc_ZPX
    lea %temp32 , [ %X64 + %arg ]
    movzx %temp32 , %temp8
END

DEF ZPX_address byte [ mem6502 + %temp64 ]

BLOCK calc_ZPY
    lea %temp32 , [ %Y64 + %arg ]
    movzx %temp32 , %temp8
END

DEF ZPY_address byte [ mem6502 + %temp64 ]


#BCD corrections
#===============
BLOCK BCD_add_correction
    movzx %temp32 , %temp8
    mov %A8 , [ BCD_to_dec + %A64 ]
    popfq
    adc %A8 , [ BCD_to_dec + %temp64 ]
    pushfq
    and dword [rsp] , ~(MASK_CF_FLAG|MASK_OF_FLAG|MASK_SF_FLAG|MASK_ZF_FLAG)

    cmp %A32 , 100
    jb .no_correction
    sub %A32 , 100
    or dword [rsp] , MASK_CF_FLAG
    .no_correction:
    
    test %A8 , %A8
    jnz .not_zero
    or dword [rsp] , MASK_ZF_FLAG
    .not_zero:
    
    mov %A8 , [ dec_to_BCD + %A64 ] 

    popfq
    jmp .done
END

BLOCK BCD_sub_correction

    movzx %temp32 , %temp8
    mov %A8 , [ BCD_to_dec + %A64 ]
    popfq
    sbb %A8 , [ BCD_to_dec + %temp64 ]
    pushfq
    and dword [rsp] , ~(MASK_CF_FLAG|MASK_OF_FLAG|MASK_SF_FLAG|MASK_ZF_FLAG)

    cmp %A8 , (256-99-1)
    jb .no_correction
    sub %A8 , (255-99)
    or dword [rsp] , MASK_CF_FLAG
    .no_correction:
    
    test %A8 , %A8
    jnz .not_zero
    or dword [rsp] , MASK_ZF_FLAG
    .not_zero:
    
    mov %A8 , [ dec_to_BCD + %A64 ] 

    popfq
    cmc
    jmp .done
END


#Emulator constants
#==================
DEF DEBUG       0xFFE7
DEF DEBUG_HEX   0xFFE8
DEF FILE_INPUT  0xFFF0
DEF PROG_EXIT   0xFFF1


#Instructions
#============
OP ADC
PRE
    pushfq
    test %D_reg , %D_reg
    je .no_BCD
POST
    .done:
MODE ABS ABSX ABSY IMMED ZP
        mov %temp8 , %mode
        %BCD_add_correction
    .no_BCD:
    popfq
    adc %A8 , %mode
MODE IX 
        %calc_IX %arg
        mov %temp8 , %IX_address
        %BCD_add_correction
    .no_BCD:
    popfq
    %calc_IX %arg
    adc %A8 , %IX_address
MODE IY
        %calc_IY %arg
        mov %temp8 , %IY_address
        %BCD_add_correction
    .no_BCD:
    popfq
    %calc_IY %arg
    adc %A8 , %IY_address
MODE ZPX
        %calc_ZPX
        mov %temp8 , %ZPX_address
        %BCD_add_correction
    .no_BCD:
    popfq
    %calc_ZPX
    adc %A8 , %ZPX_address
END

OP AND EOR ORA
X86 and xor or 
PRE
    %keep_CV_pre
POST
    %keep_CV_post
MODE ABS ABSX ABSY IMMED ZP ZPX
    %op %A8 , %mode
MODE IX
    %calc_IX
    %op %A8 , %IX_address
MODE IY
    %calc_IY
    %op %A8 , %IY_address
MODE ZPX
    %calc_ZPX
    %op %A8 , %ZPX_address
END

OP ASL LSR
X86 shl shr
PRE
    %keep_V_pre
POST
    %keep_V_post
MODE A
    %op %A8 , 1
MODE ZP ABS ABSX
    %op %mode , 1
MODE ZPX
    %calc_ZPX
    %op %ZPX_address , 1
END

OP  BCC BCS BNE BEQ BPL BMI BVC BVS
X86 jnc jc  jne je  jns js  jno jo
MODE REL
    %op %rel
END

OP BIT
MODE ABS ZP
    pushfq
    and dword [rsp] , ~(MASK_SF_FLAG|MASK_ZF_FLAG|MASK_OF_FLAG) 
    movzx %temp32 , %mode

    test %A8 , %temp8
    jnz .no_zero
    or dword [rsp] , MASK_ZF_FLAG
    .no_zero:

    test %temp8 , 0x80
    jns .no_negative
    or dword [rsp] , MASK_SF_FLAG
    .no_negative:

    test %temp8 , 0x40
    je .no_bit6
    or dword [rsp] , MASK_OF_FLAG
    .no_bit6:

    popfq
END

OP BRK
MODE IMP
    call halt_breakpoint
    debug_postfix %address
    jmp done
END

OP CLC
MODE IMP
    CLC
END

OP CLD
MODE IMP
    mov %D_reg , 0
END

OP CLI NOP SEI RTI
MODE IMP
    ;Ignored!
END

OP CLV
MODE IMP
    pushfq
    and qword [rsp], ~MASK_OF_FLAG
    popfq
END

#Technically, defining regs here defines all these modes for CPX and CPY
#even though they don't exist! No problem since will never match on those.
OP CMP CPX CPY
REGS %A8 %X8 %Y8
PRE
    %keep_V_pre
POST
    %keep_V_post
    cmc
MODE ABS ABSX ABSY IMMED ZP
    cmp %reg , %mode
MODE IX
    %calc_IX
    cmp %reg , %IX_address
MODE IY
    %calc_IY
    cmp %reg , %IY_address
MODE ZPX
    %calc_ZPX
    cmp %reg , %ZPX_address
END

OP DEC DEX DEY 
REGS NA %X8 %Y8
PRE
    %keep_V_pre
POST
    %keep_V_post
MODE ABS ABSX ZP
    dec %mode
MODE IMP
    dec %reg
MODE ZPX
    %calc_ZPX
    dec %ZPX_address
END

OP INC INX INY 
REGS NA %X8 %Y8
PRE
    %keep_V_pre
POST
    %keep_V_post
MODE ABS ABSX ZP
    inc %mode
MODE IMP
    inc %reg
MODE ZPX
    %calc_ZPX
    inc %ZPX_address
END

OP JMP
MODE JMP
    jmp %jmp
MODE I
    movzx %temp32 , word [ mem6502 + %arg ]
    mov %temp32 , [ jump_table + %temp64 * 4 ]
    jmp %temp64
END

OP JSR
MODE ABS
    mov byte [ mem6502 + 0x100 + %SP64 ], %jsr1
    lea %SP32 , [ %SP64 - 1 ]
    movzx %SP32 , %SP8
    mov byte [ mem6502 + 0x100 + %SP64 ], %jsr2
    lea %SP32 , [ %SP64 - 1 ]
    movzx %SP32 , %SP8
    debug_postfix %address
    jmp %jmp
END

#This also generates non existent combinations but no problem since it will never
#match on them.
OP LDA LDX LDY
REGS  %A32 %X32 %Y32
REGS2 %A8  %X8  %Y8
POST
    %set_NZ_keep_CV %reg2
MODE IMMED
    mov %reg , %arg
MODE ABS ABSX ABSY ZP
    movzx %reg , %mode
MODE IX
    %calc_IX %arg
    movzx %reg , %IX_address
MODE IY
    %calc_IY %arg
    movzx %reg , %IY_address
MODE ZPX
    %calc_ZPX
    movzx %reg , %ZPX_address
END

#Ok to redefine here so it will work with peripherals
OP LDA
MODE ABS
    movzx %A32 , %mode
    mov edx, %arg
    %if %arg %FILE_INPUT
    call peripheral_read
    %endif
    %set_NZ_keep_CV %A8
END

OP PHA
MODE IMP
    mov [ mem6502 + 0x100 + %SP64 ], %A8
    pushfq
    dec %SP8
    popfq
END

OP PHP
MODE IMP
    mov %temp32 , %D_reg
    lea %temp32 , [ %temp64 + I_FLAG ]

    jnc .no_carry
    lea %temp32 , [ %temp64 + C_FLAG ]
    .no_carry:
    
    jnz .no_zero
    lea %temp32 , [ %temp64 + Z_FLAG ]
    .no_zero:
    
    jno .no_overflow
    lea %temp32 , [ %temp64 + V_FLAG ]
    .no_overflow:

    jns .no_negative
    lea %temp32 , [ %temp64 + N_FLAG ]
    .no_negative:

    mov [ mem6502 + 0x100 + %SP64 ], %temp8
    lea %SP32 , [ %SP64 - 1 ]
    movzx %SP32 , %SP8
END

OP PLA
MODE IMP
    pushfq
    pop %temp64
    and %temp32 , MASK_CF_FLAG|MASK_OF_FLAG
    inc %SP8
    mov %A8 , [ mem6502 + 0x100 + %SP64 ]
    test %A8 , %A8
    pushfq
    or [rsp], %temp64
    popfq
END

OP PLP
MODE IMP
    pushfq
    pop %temp64
    and %temp32 , ~(MASK_CF_FLAG|MASK_OF_FLAG|MASK_SF_FLAG|MASK_ZF_FLAG)
    inc %SP8
    
    test byte [ mem6502 + 0x100 + %SP64 ] , C_FLAG
    je .no_carry
    lea %temp32 , [ %temp64 +  MASK_CF_FLAG ]
    .no_carry:
    
    test byte [ mem6502 + 0x100 + %SP64 ] , Z_FLAG
    je .no_zero
    lea %temp32 , [ %temp64 +  MASK_ZF_FLAG ]
    .no_zero:

    test byte [ mem6502 + 0x100 + %SP64 ] , V_FLAG
    je .no_overflow
    lea %temp32 , [ %temp64 +  MASK_OF_FLAG ]
    .no_overflow:

    test byte [ mem6502 + 0x100 + %SP64 ] , N_FLAG
    je .no_negative
    lea %temp32 , [ %temp64 +  MASK_SF_FLAG ]
    .no_negative:

    push %temp64
    popfq
END

OP ROL ROR
X86 rcl rcr
PRE
    %set_CNZ_keep_V_1
POST
    %set_CNZ_keep_V_3
MODE A
    %op %A8 , 1
    %set_CNZ_keep_V_2
    test %A8 , %A8
MODE ZP ABS ABSX
    %op %mode , 1
    %set_CNZ_keep_V_2
    cmp %mode , 0
MODE ZPX
    %calc_ZPX
    %op %ZPX_address , 1
    %set_CNZ_keep_V_2
    cmp %ZPX_address , 0
END

OP RTS
MODE IMP
    lea %SP32 , [ %SP64 + 1 ]
    movzx %SP32 , %SP8
    movzx %temp32 , byte [ mem6502 + 0x100 + %SP64 ]
    lea %SP32 , [ %SP64 + 1 ]
    movzx %SP32 , %SP8
    mov %temp8h , [ mem6502 + 0x100 + %SP64 ]
    lea %temp32 , [ jump_table + %temp64 * 4 + 4 ]
    mov %temp32 , [ %temp64 ]
    debug_postfix %address
    jmp %temp64
END

OP SBC
PRE
    cmc
    pushfq
    test %D_reg , %D_reg
    je .no_BCD
POST
    .done:
MODE ABS ABSX ABSY IMMED ZP
        mov %temp8 , %mode
        %BCD_sub_correction
    .no_BCD:
    popfq
    sbb %A8 , %mode
    cmc
MODE IX 
        %calc_IX %arg
        mov %temp , %IX_address
        %BCD_sub_correction
    .no_BCD:
    popfq
    %calc_IX %arg
    sbb %A8 , %IX_address
    cmc
MODE IY
        %calc_IY %arg
        mov %temp8 , %IY_address
        %BCD_sub_correction
    .no_BCD:
    popfq
    %calc_IY %arg
    sbb %A8 , %IY_address
    cmc
MODE ZPX
        %calc_ZPX
        mov %temp8 , %ZPX_address
        %BCD_sub_correction
    .no_BCD:
    popfq
    %calc_ZPX
    sbb %A8 , %ZPX_address
    cmc
END

OP SEC
MODE IMP
    STC
END

OP SED
MODE IMP
    mov %D_reg , D_FLAG
END

OP   STA STX STY
REGS %A8 %X8 %Y8
MODE ABS ABSX ABSY ZP
    mov %mode , %reg
MODE IX
    %calc_IX
    mov %IX_address , %reg
MODE IY
    %calc_IY %arg
    mov %IY_address , %reg
MODE ZPX
    %calc_ZPX
    mov %ZPX_address , %reg
END

#Ok to redefine here so it will work with peripherals
OP STA
MODE ABS
    mov %mode , %A8
    mov %temp32 , %arg
    %if %arg %DEBUG %DEBUG_HEX 
    call peripheral_write
    %endif
    %if %arg %PROG_EXIT
    debug_prefix %address
    call peripheral_write
    %endif
END

OP    TAX TAY TSX  TXA TYA
REGS  %X8 %Y8 %X8  %A8 %A8
REGS2 %A8 %A8 %SP8 %X8 %Y8
POST
    %set_NZ_keep_CV %reg2
MODE IMP
    mov %reg , %reg2
END

OP TXS
MODE IMP
    mov %SP8 , %X8
END

